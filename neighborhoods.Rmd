---
title: "neighborhoods"
output: html_notebook
---

## vizinhanças por contiguidade

Carregando shapefile de são paulo:
```{r}
library(rgdal)
library(tidyverse)
shp_sp <- readOGR(dsn = "data/shapefiles/SP_Municipios", layer = "SP", verbose = F)
plot(shp_sp)
```

Critério queen de vizinhança:

```{r}
library(spdep)
vizinhos_queen = poly2nb(pl = shp_sp, queen = TRUE,row.names = shp_sp@data$NM_MUN)

plot(shp_sp, border = "lightgray")
plot(vizinhos_queen, 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#33638DFF")

```
Matriz W Binária:

```{r}
matrizW_queen <- nb2mat(neighbours = vizinhos_queen, style = "B", zero.policy = T)
colnames(matrizW_queen) <- shp_sp@data$NM_MUN
```

Gerando uma lista com várias matrizes W, cada uma com contiguidades de ordem 1 até 5:
```{r}
vizinhos_queen_ordens <- nblag(neighbours = vizinhos_queen, maxlag = 5)
```

plot das vizinhanças com ordem 3:
```{r}
plot(shp_sp, border = "lightgray")
plot(vizinhos_queen_ordens[[3]], 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#33638DFF")
```

Estabelecendo vizinhanças por contiguidade, critério rook (torre, não pega diagonais):

```{r}
vizinhos_rook <- poly2nb(pl = shp_sp, queen = FALSE,row.names = shp_sp@data$NM_MUN)

plot(shp_sp, border = "lightgray")
plot(vizinhos_rook, 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#95D840FF")
```

Matriz W do critério rook:

```{r}
matrizW_rook <- nb2mat(neighbours = vizinhos_rook, style = "B", zero.policy = TRUE)
colnames(matrizW_rook) <- shp_sp@data$NM_MUN
```

## Vizinhanças por Distância Geográfica

Shapefile do estado da Bahia:

```{r}
shp_ba <- readOGR(dsn = "data/shapefiles/shapefile_ba/", layer = "ba_state", encoding = "UTF-8", use_iconv = TRUE, verbose=F)
```

vizinhanças por distâncias geográficas (as distâncias serão calculadas em km):

```{r message=FALSE, warning=FALSE}
library(spdep)
vizinhos_distancias <- dnearneigh(coordinates(shp_ba), d1 = 0, d2 = 90, longlat = TRUE)
summary(vizinhos_distancias)
```

Vizualizando as distâncias:

```{r}
plot(shp_ba, border = "lightgray")
plot(vizinhos_distancias, coordinates(shp_ba), col = "#CC6A70FF", add =T)
```

Matriz W:

```{r}
matrizW_distancias <- nb2mat(neighbours = vizinhos_distancias, style = "B")
colnames(matrizW_distancias) <- shp_ba@data$MUNICIPIO
rownames(matrizW_distancias) <- shp_ba@data$MUNICIPIO
```

## Vizinhanças Ponderadas por k-Nearest Neighbors

```{r}
library(rgdal)

shp_sc = readOGR("data/shapefiles/shapefile_sc", layer="sc_state", verbose=F)
```

Obrigando cada municipio ter exatamente 3 vizinhos:

```{r}
lista_knear <- knearneigh(coordinates(shp_sc), longlat = TRUE, k = 3)
vizinhos_knear <- knn2nb(knn = lista_knear)

plot(shp_sc, border = "lightgray")
plot(vizinhos_knear, coordinates(shp_sc), add = T, col = "#13306DFF")
```

Matriz Binária W:

```{r}
matrizW_knear  <- nb2mat(neighbours = vizinhos_knear, style = "B")
colnames(matrizW_knear) <- shp_sc@data$NM_MUNICIP
rownames(matrizW_knear) <- shp_sc@data$NM_MUNICIP
```

## Padronização em Linha da Matriz W

```{r}
matrizW_queen_linha <- nb2mat(vizinhos_queen, style = "W", zero.policy = T)
colnames(matrizW_queen_linha) <- rownames(matrizW_queen_linha)
```

São paulo tem 23 vizinhos no método queen: 
```{r}
sum(matrizW_queen["São Paulo",])
```

Quando padronizamos por linha obrigamos a soma da linha dar 1:
```{r}
sum(matrizW_queen_linha["São Paulo",])
```


## Dupla Padronização da Matriz W 

```{r}
matrizW_queen_dupla_padr <- nb2mat(vizinhos_queen, style = "U", zero.policy = T)
colnames(matrizW_queen_dupla_padr) <- rownames(matrizW_queen_dupla_padr)
```

Quando padronizamos duplamente a soma por linha não da mais 1:

```{r}
sum(matrizW_queen_dupla_padr["São Paulo",])
```

Mas a soma da matriz inteira da um:

```{r}
sum(matrizW_queen_dupla_padr)
```

## Padronização da Matriz W pela Estabilização da Variância

```{r}
matrizW_queen_est_var <- nb2mat(vizinhos_queen, style = "S", zero.policy = T)
colnames(matrizW_queen_est_var) <- rownames(matrizW_queen_est_var)
```

Nesse caso a soma de matriz nos da a quantidade de municipios com vizinhos (ilha bela não tem vizinhos no método queen):

```{r}
sum(matrizW_queen_est_var)
```

## Autocorrelação Espacial para Matriz W

Tipos:

- Auto correlação global 
- AUto correlação local (granularidade no nível da observação)


## Auto correlação global 

Recuperando IDH de são Paulo e colocando no shapefile:
```{r}
sp = read.csv("data/sp.csv")
shp_sp <- merge(x = shp_sp, y = sp, by.x = "CD_MUN", by.y = "codigo")
```

Para o cálculo da Estatística *I* de Moran, nosso algoritmo esperará como declaração um objeto de classe listw:

```{r}
listw_queen <- mat2listw(matrizW_queen)
```

Estamos verificando a correlação de uma variável contra ela mesma defasada espacialmente (ou seja, comparando com os vizinhos) em relação a uma determinada observação:

- Hipótese Nula: Não existe auto correlação global, ou seja, os valores do IDH são independentes dos vizinhos
- Hipótese Alternativa: Há correlação. Valores do IDH são dependentes dos valores dos vizinhos

Teste da Hipótese: o valor cálculado de I  (0.2328220224) é estatisticamente ao valor esperado de I (0.00155521)?
Sim, eles são estatisticamente diferente e rejeitamos a hipótese nula.

Valor esperado de I :
```{r}
-1/(644-1)
```

Estatística I de moran:

```{r}
idhs = shp_sp@data$idh
idhs_scale = scale(idhs)
I = (t(idhs_scale) %*% matrizW_queen %*%  idhs_scale /
    t(idhs_scale) %*% idhs_scale) *
  ( (length(idhs)-1)/sum(matrizW_queen) )
I
```


Como p-value = 6.695e-10 rejeitamos a hipótese nula e a estatsitica *I* de autocorrelação global é: 0.2328220224 - ou seja, existe autocorrelação global e ela é positiva.

```{r}
moran.test(x = shp_sp@data$idh, listw = listw_queen, zero.policy = T)
```

O Diagrama da Estatística *I* de Moran:

```{r}
moran.plot(x = shp_sp@data$idh, listw = listw_queen, zero.policy = TRUE, 
           xlab = "IDH", ylab = "IDH Espacialmente Defasado")
```
Interpretação:

- As linhas que dividem os quadrantes são as médias de IDH em cada eixo
- Como estamos trabalhando com a matriz de contigunidade, ilha bela não tem viznho, por isso ele está destacado com o simbolo diferente no diagrama.
- São paulo está no quadrante High-High, ou seja, tem similaridade (transbordamento espacial) e tem valores alto da variável de interesse, IDH, com vizinho que também tem IDH alto 
- àguas de são pedro  está no quadrante  High-Low e possui valores altos de IDH com vizinho com valores baixos
- Riversul está no quadrante Low-Low e tem similaridade (transbordamento espacial) e tem valores baixo da variável de interesse, IDH, com vizinhos que também tem IDH baixo 
- Ibiuna está no quadrante Low-High e possui valores baixo de IDH com vizinhos com valores altos

Diagrama de Moran com ggplot:

```{r}
idh_defasada = lag.listw(x=listw_queen, var=shp_sp@data$idh,zero.policy = T)

df = data.frame(cidade = shp_sp@data$NM_MUN, idh=shp_sp@data$idh,idh_defasada)
df["idh_defasada_na_unha"] = matrizW_queen %*% shp_sp@data$idh

plotly::ggplotly(
  df |>
    ggplot(aes(label=cidade)) +
    geom_point(aes(x=idh,y=idh_defasada), alpha=0.5,size=3) +
    geom_smooth(aes(x=idh,y=idh_defasada), method="lm", se=F) +
    geom_hline(yintercept = mean(df$idh_defasada),lty=2) +
    geom_vline(xintercept = mean(df$idh),lty=2) +
    annotate("text", x=0.66, y=18.5, label="Low-High") +
    annotate("text", x=0.84, y=18.5, label="High-High") + 
    annotate("text", x=0.66, y=-1, label="Low-Low") + 
    annotate("text", x=0.84, y=-1, label="High-Low") + 
    theme_bw()
)
```


## Auto correlação local 

1) devemos padronizar a matriz W em linha:
```{r}
matrizW_queen_linha <- nb2mat(vizinhos_queen, style = "W",zero.policy = T)
colnames(matrizW_queen_linha) = rownames(matrizW_queen_linha)
listw_queen <- mat2listw(matrizW_queen_linha)
```

Estatística Moran Local com o uso da função localmoran:
```{r}
moran_local <- localmoran(x = shp_sp@data$idh, listw = listw_queen, zero.policy = T)
```


