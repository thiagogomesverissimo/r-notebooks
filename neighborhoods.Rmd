---
title: "neighborhoods"
output: html_notebook
---

## vizinhanças por contiguidade

Carregando shapefile de são paulo:
```{r}
library(rgdal)
library(tidyverse)
shp_sp <- readOGR(dsn = "data/shapefiles/SP_Municipios", layer = "SP", verbose = F)
plot(shp_sp)
```

Critério queen de vizinhança:

```{r}
library(spdep)
vizinhos_queen = poly2nb(pl = shp_sp, queen = TRUE,row.names = shp_sp@data$NM_MUN)

plot(shp_sp, border = "lightgray")
plot(vizinhos_queen, 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#33638DFF")

```
Matriz W Binária:

```{r}
matrizW_queen <- nb2mat(neighbours = vizinhos_queen, style = "B", zero.policy = T)
colnames(matrizW_queen) <- shp_sp@data$NM_MUN
```

Gerando uma lista com várias matrizes W, cada uma com contiguidades de ordem 1 até 5:
```{r}
vizinhos_queen_ordens <- nblag(neighbours = vizinhos_queen, maxlag = 5)
```

plot das vizinhanças com ordem 3:
```{r}
plot(shp_sp, border = "lightgray")
plot(vizinhos_queen_ordens[[3]], 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#33638DFF")
```

Estabelecendo vizinhanças por contiguidade, critério rook (torre, não pega diagonais):

```{r}
vizinhos_rook <- poly2nb(pl = shp_sp, queen = FALSE,row.names = shp_sp@data$NM_MUN)

plot(shp_sp, border = "lightgray")
plot(vizinhos_rook, 
     coordinates(shp_sp), 
     add = TRUE, 
     col = "#95D840FF")
```

Matriz W do critério rook:

```{r}
matrizW_rook <- nb2mat(neighbours = vizinhos_rook, style = "B", zero.policy = TRUE)
colnames(matrizW_rook) <- shp_sp@data$NM_MUN
```

## Vizinhanças por Distância Geográfica

Shapefile do estado da Bahia:

```{r}
shp_ba <- readOGR(dsn = "data/shapefiles/shapefile_ba/", layer = "ba_state", encoding = "UTF-8", use_iconv = TRUE, verbose=F)
```

vizinhanças por distâncias geográficas (as distâncias serão calculadas em km):

```{r message=FALSE, warning=FALSE}
library(spdep)
vizinhos_distancias <- dnearneigh(coordinates(shp_ba), d1 = 0, d2 = 90, longlat = TRUE)
summary(vizinhos_distancias)
```

Vizualizando as distâncias:

```{r}
plot(shp_ba, border = "lightgray")
plot(vizinhos_distancias, coordinates(shp_ba), col = "#CC6A70FF", add =T)
```

Matriz W:

```{r}
matrizW_distancias <- nb2mat(neighbours = vizinhos_distancias, style = "B")
colnames(matrizW_distancias) <- shp_ba@data$MUNICIPIO
rownames(matrizW_distancias) <- shp_ba@data$MUNICIPIO
```

## Vizinhanças Ponderadas por k-Nearest Neighbors

```{r}
library(rgdal)

shp_sc = readOGR("data/shapefiles/shapefile_sc", layer="sc_state", verbose=F)
```

Obrigando cada municipio ter exatamente 3 vizinhos:

```{r}
lista_knear <- knearneigh(coordinates(shp_sc), longlat = TRUE, k = 3)
vizinhos_knear <- knn2nb(knn = lista_knear)

plot(shp_sc, border = "lightgray")
plot(vizinhos_knear, coordinates(shp_sc), add = T, col = "#13306DFF")
```

Matriz Binária W:

```{r}
matrizW_knear  <- nb2mat(neighbours = vizinhos_knear, style = "B")
colnames(matrizW_knear) <- shp_sc@data$NM_MUNICIP
rownames(matrizW_knear) <- shp_sc@data$NM_MUNICIP
```

## Padronização em Linha da Matriz W

```{r}
matrizW_queen_linha <- nb2mat(vizinhos_queen, style = "W", zero.policy = T)
colnames(matrizW_queen_linha) <- rownames(matrizW_queen_linha)
```

São paulo tem 23 vizinhos no método queen: 
```{r}
sum(matrizW_queen["São Paulo",])
```

Quando padronizamos por linha obrigamos a soma da linha dar 1:
```{r}
sum(matrizW_queen_linha["São Paulo",])
```


## Dupla Padronização da Matriz W 

```{r}
matrizW_queen_dupla_padr <- nb2mat(vizinhos_queen, style = "U", zero.policy = T)
colnames(matrizW_queen_dupla_padr) <- rownames(matrizW_queen_dupla_padr)
```

Quando padronizamos duplamente a soma por linha não da mais 1:

```{r}
sum(matrizW_queen_dupla_padr["São Paulo",])
```

Mas a soma da matriz inteira da um:

```{r}
sum(matrizW_queen_dupla_padr)
```

## Padronização da Matriz W pela Estabilização da Variância

```{r}
matrizW_queen_est_var <- nb2mat(vizinhos_queen, style = "S", zero.policy = T)
colnames(matrizW_queen_est_var) <- rownames(matrizW_queen_est_var)
```

Nesse caso a soma de matriz nos da a quantidade de municipios com vizinhos (ilha bela não tem vizinhos no método queen):

```{r}
sum(matrizW_queen_est_var)
```

## Autocorrelação Espacial para Matriz W

Tipos:

- Auto correlação global 
- AUto correlação local (granularidade no nível da observação)


## Auto correlação global 

Recuperando IDH de são Paulo e colocando no shapefile:
```{r}
sp = read.csv("data/sp.csv")
shp_sp <- merge(x = shp_sp, y = sp, by.x = "CD_MUN", by.y = "codigo")
```

Para o cálculo da Estatística *I* de Moran, nosso algoritmo esperará como declaração um objeto de classe listw:

```{r}
listw_queen <- mat2listw(matrizW_queen)
```

Estamos verificando a correlação de uma variável contra ela mesma defasada espacialmente (ou seja, comparando com os vizinhos) em relação a uma determinada observação:

- Hipótese Nula: Não existe auto correlação global, ou seja, os valores do IDH são independentes dos vizinhos
- Hipótese Alternativa: Há correlação. Valores do IDH são dependentes dos valores dos vizinhos

Teste da Hipótese: o valor cálculado de I  (0.2328220224) é estatisticamente ao valor esperado de I (0.00155521)?
Sim, eles são estatisticamente diferente e rejeitamos a hipótese nula.

Valor esperado de I :
```{r}
-1/(644-1)
```

Estatística I de moran:

```{r}
idhs = shp_sp@data$idh
idhs_scale = scale(idhs)
I = (t(idhs_scale) %*% matrizW_queen %*%  idhs_scale /
    t(idhs_scale) %*% idhs_scale) *
  ( (length(idhs)-1)/sum(matrizW_queen) )
I
```


Como p-value = 6.695e-10 rejeitamos a hipótese nula e a estatsitica *I* de autocorrelação global é: 0.2328220224 - ou seja, existe autocorrelação global e ela é positiva.

```{r}
moran.test(x = shp_sp@data$idh, listw = listw_queen, zero.policy = T)
```

O Diagrama da Estatística *I* de Moran:

```{r}
moran.plot(x = shp_sp@data$idh, listw = listw_queen, zero.policy = TRUE, 
           xlab = "IDH", ylab = "IDH Espacialmente Defasado")
```
Interpretação:

- As linhas que dividem os quadrantes são as médias de IDH em cada eixo
- Como estamos trabalhando com a matriz de contigunidade, ilha bela não tem viznho, por isso ele está destacado com o simbolo diferente no diagrama.
- São paulo está no quadrante High-High, ou seja, tem similaridade (transbordamento espacial) e tem valores alto da variável de interesse, IDH, com vizinho que também tem IDH alto 
- àguas de são pedro  está no quadrante  High-Low e possui valores altos de IDH com vizinho com valores baixos
- Riversul está no quadrante Low-Low e tem similaridade (transbordamento espacial) e tem valores baixo da variável de interesse, IDH, com vizinhos que também tem IDH baixo 
- Ibiuna está no quadrante Low-High e possui valores baixo de IDH com vizinhos com valores altos

Diagrama de Moran com ggplot:

```{r}
idh_defasada = lag.listw(x=listw_queen, var=shp_sp@data$idh,zero.policy = T)

df = data.frame(cidade = shp_sp@data$NM_MUN, idh=shp_sp@data$idh,idh_defasada)
df["idh_defasada_na_unha"] = matrizW_queen %*% shp_sp@data$idh

plotly::ggplotly(
  df |>
    ggplot(aes(label=cidade)) +
    geom_point(aes(x=idh,y=idh_defasada), alpha=0.5,size=3) +
    geom_smooth(aes(x=idh,y=idh_defasada), method="lm", se=F) +
    geom_hline(yintercept = mean(df$idh_defasada),lty=2) +
    geom_vline(xintercept = mean(df$idh),lty=2) +
    annotate("text", x=0.66, y=18.5, label="Low-High") +
    annotate("text", x=0.84, y=18.5, label="High-High") + 
    annotate("text", x=0.66, y=-1, label="Low-Low") + 
    annotate("text", x=0.84, y=-1, label="High-Low") + 
    theme_bw()
)
```


## Auto correlação local 

1) devemos padronizar a matriz W em linha:
```{r}
matrizW_queen_linha <- nb2mat(vizinhos_queen, style = "W",zero.policy = T)
colnames(matrizW_queen_linha) = rownames(matrizW_queen_linha)
listw_queen <- mat2listw(matrizW_queen_linha)
```

Estatística Moran Local com o uso da função localmoran:
```{r}
moran_local <- localmoran(x = shp_sp@data$idh, listw = listw_queen, zero.policy = T)
```

- Cluster Espaciais: O pontos com Moran Local estatisticamente significantes e que estejam em High-High ou Low-Low
- Outluers Espacial: O pontos com Moran Local estatisticamente significantes e que estejam em High-Low ou Low-High

```{r}
idh_zscore = scale(shp_sp@data$idh)
moran_local_na_unha = rowSums(sweep(x=matrizW_queen_linha,MARGIN=2,STATS = idh_zscore, FUN = "*"))*idh_zscore
```

Juntando os resultados da Estatística Moran Local no dataset do objeto shp_sp:
```{r}
moran_local_mapa <- cbind(shp_sp, moran_local)
```

```{r}
library(gtools)
library(tmap)
quantile(moran_local_mapa@data$Ii, type = 5, probs = c(0,0.2,0.4,0.6,0.8))

moran_local_mapa@data <- moran_local_mapa@data %>% 
  mutate(faixa_quantis = factor(quantcut(x = Ii, q = 5))) 

tm_shape(shp = moran_local_mapa) +
  tm_fill(col = "faixa_quantis", palette = "-magma") +
  tm_borders()
```

Considerando os quadrantes:

```{r}
moran_local_mapa <- cbind(moran_local_mapa, 
                          attr(x = moran_local, which = "quadr")[1])

tm_shape(shp = moran_local_mapa) +
  tm_fill(col = "mean", palette = "-viridis") +
  tm_borders(col = "gray")

```

Criando um vetor que contenha o centro das observações da variável idh ao redor de sua média:

```{r}
quadrantes <- vector(mode = "numeric", length = nrow(moran_local))
centro_idh <- shp_sp@data$idh - mean(shp_sp@data$idh)
centro_moran_local <- moran_local[,1] - mean(moran_local[,1])
```

Vamos manter na base somente os I locais significantes.
Enquadrando nossas observações em seus respectivos quadrantes:
```{r}
sig <- 0.05
quadrantes[centro_idh > 0 & centro_moran_local > 0] <- "HH"
quadrantes[centro_idh > 0 & centro_moran_local < 0] <- "HL"
quadrantes[centro_idh < 0 & centro_moran_local > 0] <- "LH"
quadrantes[centro_idh < 0 & centro_moran_local < 0] <- "LL"
```

Ajustando a presença da observação em razão de sua significância estatística:
```{r}
quadrantes[moran_local[,5] > sig] <- "Estatisticamente_não_significante"
moran_local_mapa@data["quadrantes"] <- factor(quadrantes)
```

Plotando os quadrantes de forma espacial (versão 'default'):
```{r}
tm_shape(shp = moran_local_mapa) +
  tm_polygons(col = "quadrantes", 
              pal = c(HH = "darkred",
                      HL = "red", 
                      LH = "lightblue", 
                      LL = "darkblue",
                      Estatisticamente_não_significante = "white")) +
  tm_borders()
```



# Versão do gráfico anterior para daltônicos:


# 05) Autocorrelação Local -  A Estatística G de Getis e Ord --------------

# A Estatística G de Getis e Ord, por definição, espera uma matriz espacial
# W de distâncias geográficas. Utilizaremos o objeto matrizW_distancias.

# Lembre-se de que o objeto matrizW_distancias foi calculado em razão de um
# shapefile do Estado da Bahia!

# Vamos importar os dados de IDH dos municípios da Bahia:
load("dados_ba.RData")

# Vamos adicionar os dados carregados ao nosso shapefile:
shp_ba@data %>% 
  left_join(dados_ba, by = "Codigo") ->shp_ba@data

# Um último ajuste é a transformação do objeto matrizW_distancias em um
# objeto de classe listw:
listw_dist <- mat2listw(x = matrizW_distancias)

# Calculando a Estatística G de Getis e Ord:
g_local <- localG(x = shp_ba@data$idh,
                  listw = listw_dist)

# Juntando as informações do objeto g_local ao nosso shapefile:
mapa_G <- cbind(shp_ba, as.matrix(g_local)) 

head(mapa_G@data)

# Renomeando a nova variável para facilitar:
mapa_G@data %>% 
  rename(estistica_g = 4) -> mapa_G@data

# Plotando a Estatística G de forma espacial:
tm_shape(mapa_G) + 
  tm_fill("estistica_g", 
          palette = "-viridis") + 
  tm_borders()

# Mais uma vez, o erro a respeito da quantidade de cores. Vamos ajustar:
mapa_G@data <- mapa_G@data %>% 
  mutate(faixa_quantis = factor(quantcut(x = estistica_g, q = 8))) 

# Plotando a Estatística G de forma espacial (versão 'default'):
tm_shape(mapa_G) + 
  tm_fill("faixa_quantis", 
          palette = "-RdBu") + 
  tm_borders()

# Versão do gráfico anterior para daltônicos>
tm_shape(mapa_G) + 
  tm_fill("faixa_quantis", 
          palette = "plasma") + 
  tm_borders()

# FIM ---------------------------------------------------------------------

